service:
  enabled: true
  type: LoadBalancer
  annotations:
    metallb.universe.tf/loadBalancerIPs: 139.229.134.222

controller:
  type: deployment
  replicaCount: 1

alloy:
  mounts:
    varlog: false
  stabilityLevel: generally-available
  extraPorts:
    - name: syslog-tcp
      port: 1514
      targetPort: 1514
      protocol: TCP
    - name: syslog-udp
      port: 5141
      targetPort: 5141
      protocol: UDP
    - name: otelhttp
      port: 4318
      targetPort: 4318
      protocol: TCP
  configMap:
    content: |
      discovery.relabel "syslog" {
        targets = []

        rule {
                source_labels = ["__syslog_message_hostname"]
                target_label  = "host"
        }
        rule {
                source_labels = ["__syslog_message_app_name"]
                target_label  = "app_name"
        }
      }

      loki.source.syslog "tcp" {
        listener {
          address  = ":1514"
          protocol = "tcp"
          labels   = {
            component = "loki.source.syslog",
            protocol = "tcp",
          }
        }
        forward_to = [loki.relabel.relabel.receiver]
      }

      loki.source.syslog "pfsense" {
        listener {
          address  = ":5141"
          protocol = "udp"
          labels   = { job = "pfsense" }
        }
        relabel_rules = discovery.relabel.syslog.rules
        forward_to = [loki.process.pfsense.receiver]
      }

      loki.process "pfsense" {
        stage.regex {
          expression = "^(?P<rule>\\d+),(?P<subrule>[^,]*),(?P<anchor>[^,]*),(?P<tracker>[^,]*),(?P<iface>[^,]*),(?P<reason>[^,]*),(?P<action>[^,]*),(?P<direction>[^,]*),(?P<ipver>\\d),(?P<tos>[^,]*),(?P<ecn>[^,]*),(?P<ttl>\\d+),(?P<id>\\d+),(?P<offset>\\d+),(?P<flags>[^,]*),(?P<proto_id>\\d+),(?P<proto>[^,]*),(?P<length>\\d+),(?P<src_ip>[^,]*),(?P<dst_ip>[^,]*)(?:,(?P<src_port>\\d+),(?P<dst_port>\\d+),(?P<data_len>\\d+)(?:,(?P<tcp_flags>[^,]*),(?P<seq>\\d*),(?P<ack>\\d*),(?P<window>\\d*)(?:,(?P<urg>[^,]*)(?:,(?P<options>[^,]*))?)?)?)?$"
        }

        stage.labels {
            values = {
              action    = "",
              direction = "",
              proto     = "",
              iface     = "iface",
              rule      = "",
              dst_port  = "dst_port",
              dst_ip    = "",
            }
          }

        stage.structured_metadata {
          values = {
            src_ip    = "",
            dst_ip    = "",
            src_port  = "",
            tcp_flags = "",
            tracker   = "",
          }
        }

        forward_to = [loki.write.send.receiver]
      }

      otelcol.receiver.otlp "ingest" {
        http { endpoint = ":4318" }
        output { logs = [otelcol.processor.k8sattributes.enrich.input] }
      }

      otelcol.processor.k8sattributes "enrich" {
        extract {
          label {
            from = "pod"
            key = "app.kubernetes.io/name"
            tag_name = "app.name"
          }
          label {
            from = "pod"
              key = "app"
              tag_name = "app.legacy"
          }
          label {
            from = "pod"
            key = "app.kubernetes.io/instance"
            tag_name = "instance"
          }
          label {
          from = "pod"
          key = "app.kubernetes.io/component"
          tag_name = "component"
          }
        }

        output {
          logs = [otelcol.processor.transform.derive_labels.input]
        }
      }

      otelcol.processor.transform "derive_labels" {
        error_mode = "ignore"

        log_statements {
          context = "resource"
          statements = [
            "set(resource.attributes[\"namespace\"], resource.attributes[\"k8s.namespace.name\"])",
            "set(resource.attributes[\"pod\"], resource.attributes[\"k8s.pod.name\"])",
            "set(resource.attributes[\"container\"], resource.attributes[\"k8s.container.name\"])",
            "set(resource.attributes[\"node_name\"], resource.attributes[\"k8s.node.name\"])",
            "set(resource.attributes[\"app\"], resource.attributes[\"app.name\"]) where resource.attributes[\"app.name\"] != nil",
            "set(resource.attributes[\"app\"], resource.attributes[\"app.legacy\"]) where resource.attributes[\"app\"] == nil and resource.attributes[\"app.legacy\"] != nil",
            "set(resource.attributes[\"app\"], resource.attributes[\"k8s.deployment.name\"]) where resource.attributes[\"app\"] == nil and resource.attributes[\"k8s.deployment.name\"] != nil",
            "set(resource.attributes[\"app\"], resource.attributes[\"k8s.replicaset.name\"]) where resource.attributes[\"app\"] == nil and resource.attributes[\"k8s.replicaset.name\"] != nil",
            "set(resource.attributes[\"app\"], resource.attributes[\"k8s.pod.name\"]) where resource.attributes[\"app\"] == nil",
            "set(resource.attributes[\"job\"], Concat(resource.attributes[\"namespace\"], Concat(\"/\", resource.attributes[\"app\"]))) where resource.attributes[\"namespace\"] != nil and resource.attributes[\"app\"] != nil",
          ]
        }

        output {
          logs = [otelcol.processor.attributes.loki_hints.input]
        }
      }

      otelcol.processor.attributes "loki_hints" {
        action {
          key    = "loki.resource.labels"
          action = "insert"
          value  = "job,namespace,app,instance,component,pod,container,node_name"
        }

        output {
          logs = [otelcol.exporter.loki.to_loki.input]
        }
      }

      otelcol.exporter.loki "to_loki" {
        forward_to = [loki.write.send.receiver]
      }

      loki.relabel "relabel" {
        rule {
          source_labels = ["__syslog_message_hostname"]
          target_label  = "host"
        }
        forward_to = [loki.write.send.receiver]
      }

      loki.write "send" {
        endpoint {
          url = "http://loki-gateway.loki.svc.cluster.local/loki/api/v1/push"
        }
        external_labels = { job = "alloy" }
      }

      livedebugging {
        enabled = true
      }

      logging {
        level  = "debug"
        format = "logfmt"
      }
